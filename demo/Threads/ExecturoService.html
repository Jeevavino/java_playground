<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java ExecutorService Visual Demo</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --container-bg: #16213e;
            --accent-color-1: #0f3460;
            --accent-color-2: #e94560;
            --text-color: #dcdcdc;
            --green: #2ecc71;
            --yellow: #f1c40f;
            --blue: #3498db;
            --border-radius: 8px;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: var(--accent-color-2);
            text-align: center;
            margin-bottom: 2rem;
        }

        .pool-container {
            background-color: var(--container-bg);
            border: 1px solid var(--accent-color-1);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 30px;
            width: 90%;
            max-width: 1000px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .pool-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .pool-header h2 {
            margin: 0;
            color: var(--text-color);
        }

        .pool-header button {
            background-color: var(--accent-color-2);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
            margin-left: auto;
        }

        .pool-header button:hover {
            background-color: #c73049;
        }

        .description {
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .description ul {
            padding-left: 20px;
        }

        .description strong {
            color: var(--yellow);
        }

        .visualization-area {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: flex-start;
            min-height: 100px;
        }

        .threads-box, .queue-box {
            border: 2px dashed var(--accent-color-1);
            padding: 10px;
            border-radius: var(--border-radius);
            min-height: 80px;
        }

        .threads-box {
            flex-grow: 3;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-content: flex-start;
        }

        .queue-box {
            flex-grow: 2;
        }

        .threads-box-title, .queue-box-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--blue);
            text-align: center;
        }

        .thread {
            width: 100px;
            height: 40px;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            transition: background-color 0.5s, transform 0.3s;
        }

        .thread.idle {
            background-color: var(--green);
            color: #111;
        }

        .thread.busy {
            background-color: var(--yellow);
            color: #111;
            transform: scale(1.05);
        }

        .task {
            width: 30px;
            height: 30px;
            background-color: var(--accent-color-2);
            border-radius: 50%;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            margin: 5px;
            color: white;
            font-weight: bold;
        }

        .output-log {
            background-color: #111;
            border-radius: var(--border-radius);
            padding: 15px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 1px solid var(--accent-color-1);
        }

    </style>
</head>
<body>

<h1>Java ExecutorService Thread Pool Visualizer ⚙️</h1>

<div class="pool-container">
    <div class="pool-header">
        <h2>1. Fixed Thread Pool</h2>
        <button onclick="runFixedDemo()">Run Demo</button>
    </div>
    <div class="description">
        <ul>
            <li>Maintains a <strong>fixed number of threads</strong> (3 in this demo).</li>
            <li>If all threads are busy, incoming tasks are placed in a queue to wait.</li>
            <li>Ideal for CPU-intensive tasks where you want to limit resource consumption.</li>
            <li><strong>Queue Type:</strong> Uses an unbounded <strong>`LinkedBlockingQueue`</strong>. Tasks wait here until a thread is free.</li>
        </ul>
    </div>
    <div class="visualization-area">
        <div class="threads-box">
            <div class="threads-box-title">Thread Pool (Size: 3)</div>
            <div id="fixed-threads-container"></div>
        </div>
        <div class="queue-box">
            <div class="queue-box-title">Task Queue</div>
            <div id="fixed-queue-container"></div>
        </div>
    </div>
    <div class="output-log" id="fixed-log">Click "Run Demo" to see the output...</div>
</div>

<div class="pool-container">
    <div class="pool-header">
        <h2>2. Cached Thread Pool</h2>
        <button onclick="runCachedDemo()">Run Demo</button>
    </div>
    <div class="description">
        <ul>
            <li>Creates threads <strong>as needed</strong>. Reuses idle threads if available.</li>
            <li>Threads that are idle for 60 seconds are terminated and removed from the pool.</li>
            <li>Good for executing many short-lived, asynchronous tasks.</li>
            <li><strong>Queue Type:</strong> Uses a <strong>`SynchronousQueue`</strong>. This queue has a capacity of zero; it directly hands off a task to a waiting thread. If no thread is waiting, it creates a new one.</li>
        </ul>
    </div>
    <div class="visualization-area">
        <div class="threads-box">
            <div class="threads-box-title">Thread Pool (Dynamically Sized)</div>
            <div id="cached-threads-container"></div>
        </div>
        <div class="queue-box">
            <div class="queue-box-title">Task Queue (SynchronousQueue)</div>
            <div id="cached-queue-container"></div>
        </div>
    </div>
    <div class="output-log" id="cached-log">Click "Run Demo" to see the output...</div>
</div>

<div class="pool-container">
    <div class="pool-header">
        <h2>3. Single Thread Executor</h2>
        <button onclick="runSingleDemo()">Run Demo</button>
    </div>
    <div class="description">
        <ul>
            <li>A pool with only <strong>one worker thread</strong>.</li>
            <li>Guarantees that tasks execute sequentially in the order they were submitted (FIFO).</li>
            <li>Useful when you need to ensure tasks don't run concurrently.</li>
            <li><strong>Queue Type:</strong> Uses an unbounded <strong>`LinkedBlockingQueue`</strong>, same as the Fixed Thread Pool.</li>
        </ul>
    </div>
    <div class="visualization-area">
        <div class="threads-box">
            <div class="threads-box-title">Thread Pool (Size: 1)</div>
            <div id="single-threads-container"></div>
        </div>
        <div class="queue-box">
            <div class="queue-box-title">Task Queue</div>
            <div id="single-queue-container"></div>
        </div>
    </div>
    <div class="output-log" id="single-log">Click "Run Demo" to see the output...</div>
</div>

<div class="pool-container">
    <div class="pool-header">
        <h2>4. Scheduled Thread Pool</h2>
        <button onclick="runScheduledDemo()">Run Demo</button>
    </div>
    <div class="description">
        <ul>
            <li>Executes tasks after a given delay or periodically.</li>
            <li>Useful for recurring tasks like checks, cleanups, or notifications.</li>
            <li><strong>Queue Type:</strong> Uses a <strong>`DelayedWorkQueue`</strong>. This is a specialized queue that holds tasks and only makes them available to threads when their scheduled time has arrived.</li>
        </ul>
    </div>
    <div class="visualization-area">
        <div class="threads-box">
            <div class="threads-box-title">Thread Pool (Size: 3)</div>
            <div id="scheduled-threads-container"></div>
        </div>
        <div class="queue-box">
            <div class="queue-box-title">Task Queue (DelayedWorkQueue)</div>
            <div id="scheduled-queue-container"></div>
        </div>
    </div>
    <div class="output-log" id="scheduled-log">Click "Run Demo" to see the output...</div>
</div>


<script>
    // --- UTILITY FUNCTIONS ---
    const getEl = (id) => document.getElementById(id);

    function logMessage(logId, message) {
        const logEl = getEl(logId);
        const timestamp = new Date().toLocaleTimeString();
        logEl.innerHTML += `[${timestamp}] ${message}\n`;
        logEl.scrollTop = logEl.scrollHeight; // Auto-scroll
    }

    function clearDemo(prefix) {
        getEl(`${prefix}-threads-container`).innerHTML = '';
        getEl(`${prefix}-queue-container`).innerHTML = '';
        getEl(`${prefix}-log`).innerHTML = '';
    }

    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    // --- DEMO LOGIC ---

    // 1. FIXED THREAD POOL DEMO
    async function runFixedDemo() {
        const prefix = 'fixed';
        const logId = `${prefix}-log`;
        const threadsContainer = getEl(`${prefix}-threads-container`);
        const queueContainer = getEl(`${prefix}-queue-container`);
        const threadCount = 3;
        const taskCount = 6;

        clearDemo(prefix);
        logMessage(logId, '--- Starting FixedThreadPool Demo (3 Threads, 6 Tasks) ---');

        // Create thread visuals
        let threads = [];
        for (let i = 1; i <= threadCount; i++) {
            const threadEl = document.createElement('div');
            threadEl.className = 'thread idle';
            threadEl.id = `${prefix}-thread-${i}`;
            threadEl.innerText = `Thread ${i}`;
            threadsContainer.appendChild(threadEl);
            threads.push({ el: threadEl, busy: false, name: `pool-1-thread-${i}` });
        }

        // Simulate submitting tasks
        for (let i = 1; i <= taskCount; i++) {
            logMessage(logId, `Submitting Task ${i}...`);
            await sleep(200); // Stagger submissions

            const taskEl = document.createElement('div');
            taskEl.className = 'task';
            taskEl.innerText = i;
            queueContainer.appendChild(taskEl);

            // This simulates the ExecutorService picking up tasks
            // In reality, this is more complex, but this visualizes the flow
            (async function processQueue() {
                const freeThread = threads.find(t => !t.busy);
                if (freeThread && queueContainer.children.length > 0) {
                    const taskToProcess = queueContainer.children[0];
                    queueContainer.removeChild(taskToProcess);

                    freeThread.busy = true;
                    freeThread.el.classList.replace('idle', 'busy');
                    freeThread.el.innerText = `Running T${taskToProcess.innerText}`;

                    logMessage(logId, `Task ${taskToProcess.innerText} picked up by ${freeThread.el.id.replace(prefix + '-', '')} [${freeThread.name}]`);

                    await sleep(2000); // Simulate work

                    logMessage(logId, `Task ${taskToProcess.innerText} finished.`);
                    freeThread.el.innerText = `Thread ${freeThread.el.id.split('-')[2]}`;
                    freeThread.el.classList.replace('busy', 'idle');
                    freeThread.busy = false;

                    // Check queue again for next task
                    processQueue();
                }
            })();
        }
    }

    // 2. CACHED THREAD POOL DEMO
    async function runCachedDemo() {
        const prefix = 'cached';
        const logId = `${prefix}-log`;
        const threadsContainer = getEl(`${prefix}-threads-container`);
        const queueContainer = getEl(`${prefix}-queue-container`);
        const taskCount = 5;
        let threadIdCounter = 0;

        clearDemo(prefix);
        logMessage(logId, '--- Starting CachedThreadPool Demo (5 Tasks) ---');
        logMessage(logId, 'Notice: New threads are created because tasks arrive quickly.');

        let threads = [];

        // Simulate submitting tasks
        for (let i = 1; i <= taskCount; i++) {
            logMessage(logId, `Submitting Task ${i}...`);
            await sleep(250); // Fast submissions to trigger new thread creation

            const taskEl = document.createElement('div');
            taskEl.className = 'task';
            taskEl.innerText = i;
            queueContainer.appendChild(taskEl);
            logMessage(logId, `Task ${i} hits SynchronousQueue... Looking for a thread.`);

            let freeThread = threads.find(t => !t.busy);

            if (!freeThread) {
                threadIdCounter++;
                logMessage(logId, `No idle thread found. Creating new Thread ${threadIdCounter}.`);
                const threadEl = document.createElement('div');
                threadEl.className = 'thread idle';
                threadEl.id = `${prefix}-thread-${threadIdCounter}`;
                threadEl.innerText = `Thread ${threadIdCounter}`;
                threadsContainer.appendChild(threadEl);
                freeThread = { el: threadEl, busy: false, name: `pool-2-thread-${threadIdCounter}`, id: threadIdCounter };
                threads.push(freeThread);
                await sleep(100); // Small delay for visual creation
            } else {
                logMessage(logId, `Reusing idle Thread ${freeThread.id}.`);
            }

            // Hand off task to the thread
            const taskToProcess = queueContainer.children[0];
            queueContainer.removeChild(taskToProcess);

            freeThread.busy = true;
            freeThread.el.classList.replace('idle', 'busy');
            freeThread.el.innerText = `Running T${taskToProcess.innerText}`;

            logMessage(logId, `Task ${taskToProcess.innerText} running on ${freeThread.el.id.replace(prefix + '-', '')} [${freeThread.name}]`);

            // Task completion and thread becoming idle
            (async (thread) => {
                await sleep(1500); // Simulate work
                logMessage(logId, `Task ${taskToProcess.innerText} finished.`);
                thread.el.innerText = `Thread ${thread.id}`;
                thread.el.classList.replace('busy', 'idle');
                thread.busy = false;

                // Simulate 60s timeout for termination (shortened for demo)
                logMessage(logId, `Thread ${thread.id} is idle. Will terminate in 3s if not reused.`);
                const isStillIdle = await (new Promise(resolve => {
                    setTimeout(() => resolve(!thread.busy), 3000);
                }));

                if (isStillIdle && threads.includes(thread)) {
                    logMessage(logId, `Thread ${thread.id} terminated due to inactivity.`);
                    thread.el.remove();
                    threads = threads.filter(t => t.id !== thread.id);
                }

            })(freeThread);
        }
    }

    // 3. SINGLE THREAD EXECUTOR DEMO
    async function runSingleDemo() {
        const prefix = 'single';
        const logId = `${prefix}-log`;
        const threadsContainer = getEl(`${prefix}-threads-container`);
        const queueContainer = getEl(`${prefix}-queue-container`);
        const taskCount = 4;

        clearDemo(prefix);
        logMessage(logId, '--- Starting SingleThreadExecutor Demo (4 Tasks) ---');
        logMessage(logId, 'Tasks will execute one by one.');

        // Create the single thread visual
        const threadEl = document.createElement('div');
        threadEl.className = 'thread idle';
        threadEl.id = `${prefix}-thread-1`;
        threadEl.innerText = `Thread 1`;
        threadsContainer.appendChild(threadEl);
        let thread = { el: threadEl, busy: false, name: `pool-3-thread-1` };

        for (let i = 1; i <= taskCount; i++) {
            logMessage(logId, `Submitting Task ${i}...`);
            const taskEl = document.createElement('div');
            taskEl.className = 'task';
            taskEl.innerText = i;
            queueContainer.appendChild(taskEl);
            await sleep(500);
        }

        // Process tasks from queue sequentially
        while (queueContainer.children.length > 0) {
            if (!thread.busy) {
                const taskToProcess = queueContainer.children[0];

                thread.busy = true;
                thread.el.classList.replace('idle', 'busy');
                thread.el.innerText = `Running T${taskToProcess.innerText}`;
                logMessage(logId, `Task ${taskToProcess.innerText} picked up by Single Thread [${thread.name}]`);

                // Animate task moving to thread
                queueContainer.removeChild(taskToProcess);
                await sleep(1500); // Simulate work

                logMessage(logId, `Task ${taskToProcess.innerText} finished.`);
                thread.el.innerText = `Thread 1`;
                thread.el.classList.replace('busy', 'idle');
                thread.busy = false;
            }
            await sleep(100); // small delay to prevent tight loop
        }
    }

    // 4. SCHEDULED THREAD POOL DEMO
    async function runScheduledDemo() {
        const prefix = 'scheduled';
        const logId = `${prefix}-log`;
        const threadsContainer = getEl(`${prefix}-threads-container`);
        const queueContainer = getEl(`${prefix}-queue-container`);
        const threadCount = 3;

        clearDemo(prefix);
        logMessage(logId, '--- Starting ScheduledThreadPool Demo ---');

        // Create thread visuals
        let threads = [];
        for (let i = 1; i <= threadCount; i++) {
            const threadEl = document.createElement('div');
            threadEl.className = 'thread idle';
            threadEl.id = `${prefix}-thread-${i}`;
            threadEl.innerText = `Thread ${i}`;
            threadsContainer.appendChild(threadEl);
            threads.push({ el: threadEl, busy: false, name: `pool-4-thread-${i}` });
        }

        // Function to find a thread and run a task
        async function executeTask(taskName, taskEl) {
            let freeThread = threads.find(t => !t.busy);
            while (!freeThread) {
                await sleep(100); // wait for a thread to be free
                freeThread = threads.find(t => !t.busy);
            }

            freeThread.busy = true;
            freeThread.el.classList.replace('idle', 'busy');
            freeThread.el.innerText = `Running ${taskName}`;
            logMessage(logId, `${taskName} running on ${freeThread.el.id.replace(prefix + '-', '')} [${freeThread.name}]`);
            const startTime = Date.now();

            await sleep(1500); // Simulate work

            const endTime = Date.now();
            logMessage(logId, `${taskName} finished. [${(endTime - startTime)}ms elapsed]`);
            freeThread.el.innerText = `Thread ${freeThread.el.id.split('-')[2]}`;
            freeThread.el.classList.replace('busy', 'idle');
            freeThread.busy = false;
        }

        // 1. schedule() - one-time task
        logMessage(logId, "Scheduling one-time task (S1) to run in 2 seconds...");
        setTimeout(() => {
            logMessage(logId, "One-time task S1 is now ready to run.");
            executeTask('S1');
        }, 2000);

        // 2. scheduleAtFixedRate()
        let rateCounter = 0;
        logMessage(logId, "Scheduling FixedRate task (FR) to run every 3 seconds (task takes 1.5s).");
        const rateInterval = setInterval(() => {
            rateCounter++;
            if (rateCounter > 3) {
                clearInterval(rateInterval);
                logMessage(logId, "--- FixedRate task (FR) stopped. ---");
                return;
            }
            const taskName = `FR${rateCounter}`;
            logMessage(logId, `FixedRate task ${taskName} is now ready to run.`);
            executeTask(taskName);
        }, 3000);

        // 3. scheduleWithFixedDelay()
        let delayCounter = 0;
        logMessage(logId, "Scheduling FixedDelay task (FD) to run with 3 second delay after completion (task takes 1.5s).");
        async function runFixedDelayTask() {
            delayCounter++;
            if (delayCounter > 3) {
                logMessage(logId, "--- FixedDelay task (FD) stopped. ---");
                return;
            }
            const taskName = `FD${delayCounter}`;
            logMessage(logId, `FixedDelay task ${taskName} is now ready to run.`);
            await executeTask(taskName);

            logMessage(logId, `Waiting 3 seconds before scheduling next FixedDelay task...`);
            setTimeout(runFixedDelayTask, 3000);
        }
        setTimeout(runFixedDelayTask, 1000); // Initial delay
    }

</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Thread Creation Methods Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            text-align: center;
        }

        .btn {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
        }

        .demo-section {
            padding: 30px;
        }

        .method-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            margin: 20px 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .method-card.active {
            border-color: #4facfe;
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.3);
            transform: scale(1.02);
        }

        .method-header {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            cursor: pointer;
        }

        .method-header h3 {
            font-size: 1.3rem;
            margin-bottom: 5px;
        }

        .method-content {
            padding: 20px;
            display: none;
        }

        .method-content.show {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
            margin: 15px 0;
            border-left: 4px solid #4facfe;
        }

        .thread-visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
        }

        .thread-item {
            background: linear-gradient(45deg, #ff9a9e, #fecfef);
            border-radius: 10px;
            padding: 15px;
            min-width: 200px;
            text-align: center;
            transform: scale(0.9);
            opacity: 0;
            transition: all 0.5s ease;
        }

        .thread-item.animate {
            transform: scale(1);
            opacity: 1;
        }

        .thread-item.running {
            background: linear-gradient(45deg, #a8edea, #fed6e3);
            animation: pulse 2s infinite;
        }

        .thread-item.completed {
            background: linear-gradient(45deg, #d299c2, #fef9d7);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .execution-log {
            background: #1a202c;
            color: #68d391;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 300px;
            overflow-y: auto;
            margin: 20px 0;
            border: 2px solid #4a5568;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .highlight {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .advantage, .disadvantage {
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
        }

        .advantage {
            background: #d4edda;
            border-left: 4px solid #28a745;
        }

        .disadvantage {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            width: 0%;
            transition: width 0.5s ease;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>üßµ Java Thread Creation Methods</h1>
        <p>Interactive Demo of 6 Different Ways to Create Threads in Java</p>
    </div>

    <div class="controls">
        <button class="btn" onclick="startDemo()">‚ñ∂Ô∏è Start Demo</button>
        <button class="btn" onclick="resetDemo()">üîÑ Reset</button>
        <button class="btn" onclick="toggleAllMethods()">üìã Toggle All Methods</button>
    </div>

    <div class="demo-section">
        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="totalTasks">0</div>
                <div>Total Tasks</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="activeThreads">0</div>
                <div>Active Threads</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="completedTasks">0</div>
                <div>Completed Tasks</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="currentMethod">-</div>
                <div>Current Method</div>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="execution-log" id="executionLog">
            <div>üöÄ Ready to start thread creation demo...</div>
            <div>üìñ Click "Start Demo" to begin execution simulation</div>
        </div>

        <!-- Method 1: Extending Thread -->
        <div class="method-card" id="method1">
            <div class="method-header" onclick="toggleMethod(1)">
                <h3>Method 1: Extending Thread Class</h3>
                <p>Direct inheritance approach - Traditional but limited</p>
            </div>
            <div class="method-content">
                <div class="highlight">
                    <strong>Concept:</strong> Create a class that extends Thread and override the run() method.
                </div>
                <div class="code-block">
                    class MyThread extends Thread {
                    private String taskName;

                    public MyThread(String taskName) {
                    this.taskName = taskName;
                    }

                    @Override
                    public void run() {
                    // Thread execution logic here
                    System.out.println("Extending Thread: " + taskName);
                    simulateWork();
                    }
                    }</div>
                <div class="advantage">‚úÖ Simple and straightforward to understand</div>
                <div class="disadvantage">‚ùå No multiple inheritance - class can't extend anything else</div>
                <div class="thread-visualization" id="threads1"></div>
            </div>
        </div>

        <!-- Method 2: Implementing Runnable -->
        <div class="method-card" id="method2">
            <div class="method-header" onclick="toggleMethod(2)">
                <h3>Method 2: Implementing Runnable Interface</h3>
                <p>Composition over inheritance - More flexible approach</p>
            </div>
            <div class="method-content">
                <div class="highlight">
                    <strong>Concept:</strong> Implement Runnable interface and pass it to Thread constructor.
                </div>
                <div class="code-block">
                    class MyTask implements Runnable {
                    private String taskName;

                    public MyTask(String taskName) {
                    this.taskName = taskName;
                    }

                    @Override
                    public void run() {
                    // Thread execution logic here
                    System.out.println("Implementing Runnable: " + taskName);
                    simulateWork();
                    }
                    }</div>
                <div class="advantage">‚úÖ Better design - separation of task and thread management</div>
                <div class="advantage">‚úÖ Class can extend other classes if needed</div>
                <div class="thread-visualization" id="threads2"></div>
            </div>
        </div>

        <!-- Method 3: Lambda Expressions -->
        <div class="method-card" id="method3">
            <div class="method-header" onclick="toggleMethod(3)">
                <h3>Method 3: Lambda Expressions (Java 8+)</h3>
                <p>Functional programming approach - Concise and modern</p>
            </div>
            <div class="method-content">
                <div class="highlight">
                    <strong>Concept:</strong> Use lambda expressions to define thread behavior inline.
                </div>
                <div class="code-block">
                    Thread lambdaThread = new Thread(() -> {
                    int taskId = counter.incrementAndGet();
                    System.out.println("Lambda Expression: LambdaTask" +
                    " | Task ID: " + taskId);
                    simulateWork();
                    });
                    lambdaThread.start();</div>
                <div class="advantage">‚úÖ Very concise code for simple tasks</div>
                <div class="advantage">‚úÖ No need to create separate classes</div>
                <div class="disadvantage">‚ùå Not suitable for complex logic</div>
                <div class="thread-visualization" id="threads3"></div>
            </div>
        </div>

        <!-- Method 4: Executor Framework -->
        <div class="method-card" id="method4">
            <div class="method-header" onclick="toggleMethod(4)">
                <h3>Method 4: Executor Framework (Thread Pool)</h3>
                <p>Professional approach - Managed thread lifecycle</p>
            </div>
            <div class="method-content">
                <div class="highlight">
                    <strong>Concept:</strong> Use ExecutorService to manage a pool of threads efficiently.
                </div>
                <div class="code-block">
                    ExecutorService executor = Executors.newFixedThreadPool(3);

                    // Submit tasks
                    executor.submit(new MyTask("ExecutorTask-1"));
                    executor.submit(() -> {
                    // Lambda task
                    System.out.println("Executor Lambda Task");
                    simulateWork();
                    });

                    executor.shutdown();</div>
                <div class="advantage">‚úÖ Better resource management</div>
                <div class="advantage">‚úÖ Thread reuse reduces overhead</div>
                <div class="advantage">‚úÖ Built-in thread pool management</div>
                <div class="thread-visualization" id="threads4"></div>
            </div>
        </div>

        <!-- Method 5: Callable with Future -->
        <div class="method-card" id="method5">
            <div class="method-header" onclick="toggleMethod(5)">
                <h3>Method 5: Callable with Future (Return Values)</h3>
                <p>Task with results - Can return values and handle exceptions</p>
            </div>
            <div class="method-content">
                <div class="highlight">
                    <strong>Concept:</strong> Use Callable interface to create tasks that return values.
                </div>
                <div class="code-block">
                    class MyCallable implements Callable&lt;String&gt; {
                    @Override
                    public String call() throws Exception {
                    simulateWork();
                    return "Result from task";
                    }
                    }

                    Future&lt;String&gt; future = executor.submit(new MyCallable());
                    String result = future.get(); // Get the result</div>
                <div class="advantage">‚úÖ Can return values from tasks</div>
                <div class="advantage">‚úÖ Better exception handling</div>
                <div class="advantage">‚úÖ Can check task completion status</div>
                <div class="thread-visualization" id="threads5"></div>
            </div>
        </div>

        <!-- Method 6: Virtual Threads -->
        <div class="method-card" id="method6">
            <div class="method-header" onclick="toggleMethod(6)">
                <h3>Method 6: Virtual Threads (Java 21+)</h3>
                <p>Lightweight threads - Future of concurrent programming</p>
            </div>
            <div class="method-content">
                <div class="highlight">
                    <strong>Concept:</strong> Ultra-lightweight threads managed by the JVM.
                </div>
                <div class="code-block">
                    Thread virtualThread = Thread.ofVirtual().start(() -> {
                    int taskId = counter.incrementAndGet();
                    System.out.println("Virtual Thread: VirtualTask" +
                    " | Task ID: " + taskId);
                    simulateWork();
                    });

                    // Or using factory
                    ThreadFactory factory = Thread.ofVirtual().factory();
                    Thread vt = factory.newThread(task);
                    vt.start();</div>
                <div class="advantage">‚úÖ Extremely lightweight (millions possible)</div>
                <div class="advantage">‚úÖ Perfect for I/O-bound tasks</div>
                <div class="advantage">‚úÖ Automatic resource management</div>
                <div class="highlight">
                    <strong>Note:</strong> Virtual threads are preview feature in Java 19-20, stable in Java 21+
                </div>
                <div class="thread-visualization" id="threads6"></div>
            </div>
        </div>
    </div>
</div>

<script>
    let taskCounter = 0;
    let activeThreads = 0;
    let completedTasks = 0;
    let currentMethod = 0;
    let demoRunning = false;

    const methods = [
        'Extending Thread',
        'Implementing Runnable',
        'Lambda Expressions',
        'Executor Framework',
        'Callable with Future',
        'Virtual Threads'
    ];

    function updateStats() {
        document.getElementById('totalTasks').textContent = taskCounter;
        document.getElementById('activeThreads').textContent = activeThreads;
        document.getElementById('completedTasks').textContent = completedTasks;
        document.getElementById('currentMethod').textContent =
            currentMethod > 0 ? currentMethod : '-';
    }

    function logExecution(message, type = 'info') {
        const log = document.getElementById('executionLog');
        const timestamp = new Date().toLocaleTimeString();
        const emoji = type === 'start' ? 'üöÄ' : type === 'complete' ? '‚úÖ' : type === 'error' ? '‚ùå' : 'üìù';
        log.innerHTML += `<div>${emoji} [${timestamp}] ${message}</div>`;
        log.scrollTop = log.scrollHeight;
    }

    function createThreadVisualization(methodNum, threadName, taskId) {
        const container = document.getElementById(`threads${methodNum}`);
        const threadItem = document.createElement('div');
        threadItem.className = 'thread-item';
        threadItem.innerHTML = `
                <strong>${threadName}</strong><br>
                Task ID: ${taskId}<br>
                Status: <span class="status">Starting...</span>
            `;
        container.appendChild(threadItem);

        // Animate appearance
        setTimeout(() => {
            threadItem.classList.add('animate');
        }, 100);

        // Simulate running
        setTimeout(() => {
            threadItem.classList.add('running');
            threadItem.querySelector('.status').textContent = 'Running';
            activeThreads++;
            updateStats();
        }, 500);

        // Simulate completion
        setTimeout(() => {
            threadItem.classList.remove('running');
            threadItem.classList.add('completed');
            threadItem.querySelector('.status').textContent = 'Completed';
            activeThreads--;
            completedTasks++;
            updateStats();
        }, 2000 + Math.random() * 2000); // 2-4 seconds

        return threadItem;
    }

    function simulateMethod(methodNum) {
        return new Promise((resolve) => {
            currentMethod = methodNum;
            updateStats();

            const methodCard = document.getElementById(`method${methodNum}`);
            methodCard.classList.add('active');

            logExecution(`Starting Method ${methodNum}: ${methods[methodNum - 1]}`, 'start');

            let tasksToCreate = methodNum === 4 ? 3 : 2; // Executor creates 3 tasks
            let tasksCreated = 0;

            const createTask = () => {
                if (tasksCreated < tasksToCreate) {
                    taskCounter++;
                    const taskName = `${methods[methodNum - 1]}-${tasksCreated + 1}`;
                    createThreadVisualization(methodNum, taskName, taskCounter);
                    logExecution(`Created thread: ${taskName} (Task ID: ${taskCounter})`);
                    tasksCreated++;

                    setTimeout(createTask, 800);
                } else {
                    // Wait for all threads to complete, then resolve
                    setTimeout(() => {
                        methodCard.classList.remove('active');
                        logExecution(`Method ${methodNum} completed`, 'complete');
                        resolve();
                    }, 4000);
                }
            };

            createTask();
        });
    }

    async function startDemo() {
        if (demoRunning) return;

        demoRunning = true;
        resetDemo();

        const startBtn = document.querySelector('button[onclick="startDemo()"]');
        startBtn.disabled = true;
        startBtn.textContent = '‚è≥ Running Demo...';

        logExecution('=== Java Thread Creation Methods Demo ===', 'start');

        let progress = 0;
        const progressFill = document.getElementById('progressFill');

        for (let i = 1; i <= 6; i++) {
            if (i === 6) {
                logExecution('Note: Virtual Threads require Java 21+', 'info');
            }

            await simulateMethod(i);
            progress = (i / 6) * 100;
            progressFill.style.width = `${progress}%`;

            if (i < 6) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }

        currentMethod = 0;
        updateStats();
        logExecution('=== All threads completed! ===', 'complete');
        logExecution(`Total tasks executed: ${taskCounter}`, 'complete');

        startBtn.disabled = false;
        startBtn.textContent = '‚ñ∂Ô∏è Start Demo';
        demoRunning = false;
    }

    function resetDemo() {
        taskCounter = 0;
        activeThreads = 0;
        completedTasks = 0;
        currentMethod = 0;
        updateStats();

        // Clear all thread visualizations
        for (let i = 1; i <= 6; i++) {
            document.getElementById(`threads${i}`).innerHTML = '';
            document.getElementById(`method${i}`).classList.remove('active');
        }

        // Reset progress bar
        document.getElementById('progressFill').style.width = '0%';

        // Clear log
        document.getElementById('executionLog').innerHTML = `
                <div>üöÄ Ready to start thread creation demo...</div>
                <div>üìñ Click "Start Demo" to begin execution simulation</div>
            `;
    }

    function toggleMethod(methodNum) {
        const content = document.querySelector(`#method${methodNum} .method-content`);
        content.classList.toggle('show');
    }

    function toggleAllMethods() {
        for (let i = 1; i <= 6; i++) {
            const content = document.querySelector(`#method${i} .method-content`);
            if (content.classList.contains('show')) {
                content.classList.remove('show');
            } else {
                content.classList.add('show');
            }
        }
    }

    // Initialize
    updateStats();

    // Auto-expand first method on load
    setTimeout(() => {
        toggleMethod(1);
    }, 500);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semaphore, CountDownLatch & CyclicBarrier Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            background: #f5f5f5;
            border-bottom: 3px solid #667eea;
        }

        .tab {
            flex: 1;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            background: #e0e0e0;
            border: none;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s;
            color: #333;
        }

        .tab:hover {
            background: #d0d0d0;
        }

        .tab.active {
            background: white;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .tab-content {
            display: none;
            padding: 40px;
            animation: fadeIn 0.5s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .concept-box {
            background: #f0f4ff;
            border-left: 5px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .concept-box h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.5em;
        }

        .concept-box p {
            line-height: 1.8;
            color: #555;
            font-size: 1.1em;
        }

        .demo-section {
            margin: 30px 0;
            padding: 25px;
            background: #fff;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
        }

        .demo-section h3 {
            color: #764ba2;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .visual-area {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
            min-height: 300px;
        }

        .parking-lot {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .parking-space {
            background: #28a745;
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            transition: all 0.3s;
        }

        .parking-space.occupied {
            background: #dc3545;
        }

        .waiting-cars {
            margin-top: 20px;
            padding: 20px;
            background: #fff3cd;
            border-radius: 8px;
        }

        .waiting-cars h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .car-item {
            display: inline-block;
            margin: 5px;
            padding: 10px 15px;
            background: #ffc107;
            border-radius: 20px;
            color: #333;
            font-weight: bold;
        }

        .runner-track {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
        }

        .runner-lane {
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 15px;
            position: relative;
            height: 60px;
        }

        .runner {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            font-size: 2em;
            transition: left 0.5s ease-in-out;
        }

        .finish-line {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #28a745;
        }

        .latch-counter {
            background: #667eea;
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
            font-size: 2em;
            font-weight: bold;
        }

        .player-area {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .player-box {
            background: white;
            border: 3px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .player-status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        .status-loading {
            background: #fff3cd;
            color: #856404;
        }

        .status-ready {
            background: #d4edda;
            color: #155724;
        }

        .status-playing {
            background: #d1ecf1;
            color: #0c5460;
        }

        .barrier-indicator {
            background: #dc3545;
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            margin: 20px 0;
            font-size: 1.2em;
            font-weight: bold;
        }

        .barrier-indicator.open {
            background: #28a745;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 10px 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .code-block .keyword {
            color: #569cd6;
        }

        .code-block .string {
            color: #ce9178;
        }

        .code-block .comment {
            color: #6a9955;
        }

        .code-block .method {
            color: #dcdcaa;
        }

        .code-block .type {
            color: #4ec9b0;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 15px;
            text-align: left;
            border: 1px solid #ddd;
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .method-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            transition: all 0.3s;
        }

        .method-card:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-color: #667eea;
        }

        .method-card h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .method-signature {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            margin: 10px 0;
            color: #333;
        }

        .highlight-box {
            background: #d4edda;
            border: 2px solid #28a745;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .highlight-box strong {
            color: #155724;
        }

        ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        ul li {
            margin: 8px 0;
        }

        .log-area {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>üîß Java Synchronization Utilities</h1>
        <p>Semaphore, CountDownLatch & CyclicBarrier Explained</p>
    </div>

    <div class="tabs">
        <button class="tab active" onclick="switchTab(0)">
            üöó Semaphore
        </button>
        <button class="tab" onclick="switchTab(1)">
            üèÉ CountDownLatch
        </button>
        <button class="tab" onclick="switchTab(2)">
            üéÆ CyclicBarrier
        </button>
        <button class="tab" onclick="switchTab(3)">
            üìä Comparison
        </button>
    </div>

    <!-- TAB 1: Semaphore -->
    <div class="tab-content active" id="tab0">
        <h2 style="color: #667eea; margin-bottom: 20px;">Semaphore - Limiting Concurrent Access</h2>

        <div class="concept-box">
            <h3>üéØ What is Semaphore?</h3>
            <p>
                A Semaphore controls access to a shared resource through the use of permits.
                It's like a bouncer at a club - only a fixed number of threads can access the resource at a time.
                When a thread wants access, it must acquire a permit. When done, it releases the permit for others.
            </p>
        </div>

        <div class="demo-section">
            <h3>Interactive Demo: Parking Lot (3 Spaces)</h3>
            <p style="margin-bottom: 15px;">Only 3 cars can park at a time. Others must wait for a space to free up.</p>

            <div class="visual-area">
                <h4 style="color: #667eea; margin-bottom: 15px;">üÖøÔ∏è Parking Spaces</h4>
                <div class="parking-lot">
                    <div class="parking-space" id="space1">EMPTY</div>
                    <div class="parking-space" id="space2">EMPTY</div>
                    <div class="parking-space" id="space3">EMPTY</div>
                </div>

                <div class="waiting-cars" id="waiting-area">
                    <h4>‚è≥ Waiting Cars: <span id="waiting-count">0</span></h4>
                    <div id="waiting-list"></div>
                </div>
            </div>

            <button class="btn" id="semaphore-btn" onclick="demonstrateSemaphore()">Run Semaphore Demo</button>

            <div class="log-area" id="semaphore-log"></div>
        </div>

        <div class="demo-section">
            <h3>Code Example</h3>
            <div class="code-block">
                <span class="comment">// Create semaphore with 3 permits</span>
                Semaphore parkingLot = <span class="keyword">new</span> <span class="type">Semaphore</span>(<span class="string">3</span>);

                ExecutorService executor = Executors.<span class="method">newFixedThreadPool</span>(<span class="string">6</span>);

                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">1</span>; i <= <span class="string">6</span>; i++) {
                <span class="keyword">final</span> <span class="keyword">int</span> carNumber = i;

                executor.<span class="method">submit</span>(() -> {
                <span class="keyword">try</span> {
                parkingLot.<span class="method">acquire</span>(); <span class="comment">// Get permit</span>
                System.out.<span class="method">println</span>(<span class="string">"Car "</span> + carNumber + <span class="string">" PARKED"</span>);

                Thread.<span class="method">sleep</span>(<span class="string">2000</span>); <span class="comment">// Park for 2 seconds</span>

                parkingLot.<span class="method">release</span>(); <span class="comment">// Return permit</span>
                System.out.<span class="method">println</span>(<span class="string">"Car "</span> + carNumber + <span class="string">" LEFT"</span>);
                } <span class="keyword">catch</span> (InterruptedException e) {
                Thread.<span class="method">currentThread</span>().<span class="method">interrupt</span>();
                }
                });
                }
            </div>
        </div>

        <div class="demo-section">
            <h3>Key Methods</h3>

            <div class="method-card">
                <h4>acquire()</h4>
                <div class="method-signature">void acquire() throws InterruptedException</div>
                <p>Acquires a permit. If no permit is available, the thread waits until one is released.</p>
            </div>

            <div class="method-card">
                <h4>release()</h4>
                <div class="method-signature">void release()</div>
                <p>Releases a permit, returning it to the semaphore. This wakes up a waiting thread.</p>
            </div>

            <div class="method-card">
                <h4>availablePermits()</h4>
                <div class="method-signature">int availablePermits()</div>
                <p>Returns the current number of permits available.</p>
            </div>
        </div>

        <div class="highlight-box">
            <strong>üí° Use Case:</strong> Semaphore is perfect for limiting concurrent access to a resource like
            database connections, thread pools, or rate limiting API calls.
        </div>
    </div>

    <!-- TAB 2: CountDownLatch -->
    <div class="tab-content" id="tab1">
        <h2 style="color: #667eea; margin-bottom: 20px;">CountDownLatch - Wait for Multiple Tasks</h2>

        <div class="concept-box">
            <h3>üéØ What is CountDownLatch?</h3>
            <p>
                A CountDownLatch allows one or more threads to wait until a set of operations being performed by other threads completes.
                It's initialized with a count, and threads call await() to wait. Other threads call countDown() to decrease the count.
                When the count reaches zero, all waiting threads are released.
            </p>
        </div>

        <div class="demo-section">
            <h3>Interactive Demo: Race Finish Line</h3>
            <p style="margin-bottom: 15px;">The race organizer waits for all 4 runners to finish before declaring the race complete.</p>

            <div class="visual-area">
                <div class="latch-counter" id="latch-counter">Count: 4</div>

                <h4 style="color: #667eea; margin: 20px 0;">üèÉ Runners</h4>
                <div class="runner-track">
                    <div class="runner-lane" id="lane1">
                        <span class="runner">üèÉ</span>
                        <span style="margin-left: 50px; color: #666;">Runner 1</span>
                        <div class="finish-line"></div>
                    </div>
                    <div class="runner-lane" id="lane2">
                        <span class="runner">üèÉ</span>
                        <span style="margin-left: 50px; color: #666;">Runner 2</span>
                        <div class="finish-line"></div>
                    </div>
                    <div class="runner-lane" id="lane3">
                        <span class="runner">üèÉ</span>
                        <span style="margin-left: 50px; color: #666;">Runner 3</span>
                        <div class="finish-line"></div>
                    </div>
                    <div class="runner-lane" id="lane4">
                        <span class="runner">üèÉ</span>
                        <span style="margin-left: 50px; color: #666;">Runner 4</span>
                        <div class="finish-line"></div>
                    </div>
                </div>

                <div id="race-status" style="text-align: center; font-size: 1.2em; margin-top: 20px; color: #667eea;">
                    üèÅ Waiting for runners to finish...
                </div>
            </div>

            <button class="btn" id="latch-btn" onclick="demonstrateCountDownLatch()">Run CountDownLatch Demo</button>

            <div class="log-area" id="latch-log"></div>
        </div>

        <div class="demo-section">
            <h3>Code Example</h3>
            <div class="code-block">
                <span class="comment">// Create latch with count of 4</span>
                CountDownLatch raceLatch = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="string">4</span>);

                ExecutorService executor = Executors.<span class="method">newFixedThreadPool</span>(<span class="string">5</span>);

                <span class="comment">// Main thread - Organizer</span>
                executor.<span class="method">submit</span>(() -> {
                <span class="keyword">try</span> {
                System.out.<span class="method">println</span>(<span class="string">"Race started! Waiting..."</span>);
                raceLatch.<span class="method">await</span>(); <span class="comment">// Wait until count reaches 0</span>
                System.out.<span class="method">println</span>(<span class="string">"ALL RUNNERS FINISHED!"</span>);
                } <span class="keyword">catch</span> (InterruptedException e) {
                Thread.<span class="method">currentThread</span>().<span class="method">interrupt</span>();
                }
                });

                <span class="comment">// 4 runners</span>
                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">1</span>; i <= <span class="string">4</span>; i++) {
                <span class="keyword">final</span> <span class="keyword">int</span> runnerNumber = i;
                executor.<span class="method">submit</span>(() -> {
                <span class="keyword">try</span> {
                System.out.<span class="method">println</span>(<span class="string">"Runner "</span> + runnerNumber + <span class="string">" running..."</span>);
                Thread.<span class="method">sleep</span>((<span class="keyword">long</span>) (Math.<span class="method">random</span>() * <span class="string">3000</span>));

                System.out.<span class="method">println</span>(<span class="string">"Runner "</span> + runnerNumber + <span class="string">" FINISHED!"</span>);
                raceLatch.<span class="method">countDown</span>(); <span class="comment">// Decrease count</span>
                } <span class="keyword">catch</span> (InterruptedException e) {
                Thread.<span class="method">currentThread</span>().<span class="method">interrupt</span>();
                }
                });
                }
            </div>
        </div>

        <div class="demo-section">
            <h3>Key Methods</h3>

            <div class="method-card">
                <h4>await()</h4>
                <div class="method-signature">void await() throws InterruptedException</div>
                <p>Causes the current thread to wait until the latch count reaches zero.</p>
            </div>

            <div class="method-card">
                <h4>countDown()</h4>
                <div class="method-signature">void countDown()</div>
                <p>Decrements the count of the latch. When count reaches zero, all waiting threads are released.</p>
            </div>

            <div class="method-card">
                <h4>getCount()</h4>
                <div class="method-signature">long getCount()</div>
                <p>Returns the current count.</p>
            </div>
        </div>

        <div class="highlight-box">
            <strong>üí° Use Case:</strong> CountDownLatch is ideal when one thread needs to wait for multiple worker threads
            to complete (e.g., waiting for all services to start, or all data processing tasks to finish).
        </div>

        <div class="highlight-box" style="background: #fff3cd; border-color: #ffc107;">
            <strong style="color: #856404;">‚ö†Ô∏è Important:</strong> CountDownLatch is one-time use only. Once the count reaches zero,
            it cannot be reset. Use CyclicBarrier if you need reusability.
        </div>
    </div>

    <!-- TAB 3: CyclicBarrier -->
    <div class="tab-content" id="tab2">
        <h2 style="color: #667eea; margin-bottom: 20px;">CyclicBarrier - Synchronize at Barrier Point</h2>

        <div class="concept-box">
            <h3>üéØ What is CyclicBarrier?</h3>
            <p>
                A CyclicBarrier allows a set of threads to wait for each other at a common barrier point.
                All threads must reach the barrier before any can proceed. Unlike CountDownLatch, it's reusable (cyclic) -
                after all threads pass the barrier, it resets and can be used again.
            </p>
        </div>

        <div class="demo-section">
            <h3>Interactive Demo: Multiplayer Game</h3>
            <p style="margin-bottom: 15px;">3 players must wait for each other before the game can start each round.</p>

            <div class="visual-area">
                <div class="barrier-indicator" id="barrier-status">
                    üö´ BARRIER CLOSED - Waiting for all players...
                </div>

                <div class="player-area">
                    <div class="player-box">
                        <div style="font-size: 3em;">üë§</div>
                        <h4>Player 1</h4>
                        <div class="player-status status-loading" id="player1-status">Ready</div>
                    </div>
                    <div class="player-box">
                        <div style="font-size: 3em;">üë§</div>
                        <h4>Player 2</h4>
                        <div class="player-status status-loading" id="player2-status">Ready</div>
                    </div>
                    <div class="player-box">
                        <div style="font-size: 3em;">üë§</div>
                        <h4>Player 3</h4>
                        <div class="player-status status-loading" id="player3-status">Ready</div>
                    </div>
                </div>

                <div style="text-align: center; margin-top: 20px; font-size: 1.2em; color: #667eea;">
                    <span id="round-status">Ready to start...</span>
                </div>
            </div>

            <button class="btn" id="barrier-btn" onclick="demonstrateCyclicBarrier()">Run CyclicBarrier Demo</button>

            <div class="log-area" id="barrier-log"></div>
        </div>

        <div class="demo-section">
            <h3>Code Example</h3>
            <div class="code-block">
                <span class="comment">// Create barrier for 3 threads with action when all arrive</span>
                CyclicBarrier gameBarrier = <span class="keyword">new</span> <span class="type">CyclicBarrier</span>(<span class="string">3</span>, () -> {
                System.out.<span class="method">println</span>(<span class="string">"ALL PLAYERS READY! Game starting..."</span>);
                });

                ExecutorService executor = Executors.<span class="method">newFixedThreadPool</span>(<span class="string">3</span>);

                <span class="comment">// 3 players</span>
                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">1</span>; i <= <span class="string">3</span>; i++) {
                <span class="keyword">final</span> <span class="keyword">int</span> playerNumber = i;

                executor.<span class="method">submit</span>(() -> {
                <span class="keyword">try</span> {
                <span class="comment">// Round 1: Loading</span>
                System.out.<span class="method">println</span>(<span class="string">"Player "</span> + playerNumber + <span class="string">" loading..."</span>);
                Thread.<span class="method">sleep</span>((<span class="keyword">long</span>) (Math.<span class="method">random</span>() * <span class="string">2000</span>));

                gameBarrier.<span class="method">await</span>(); <span class="comment">// Wait at barrier</span>

                <span class="comment">// Playing Round 1</span>
                System.out.<span class="method">println</span>(<span class="string">"Player "</span> + playerNumber + <span class="string">" playing Round 1"</span>);
                Thread.<span class="method">sleep</span>(<span class="string">1500</span>);

                gameBarrier.<span class="method">await</span>(); <span class="comment">// Reusable barrier!</span>

                <span class="comment">// Playing Round 2</span>
                System.out.<span class="method">println</span>(<span class="string">"Player "</span> + playerNumber + <span class="string">" playing Round 2"</span>);

                } <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) {
                Thread.<span class="method">currentThread</span>().<span class="method">interrupt</span>();
                }
                });
                }
            </div>
        </div>

        <div class="demo-section">
            <h3>Key Methods</h3>

            <div class="method-card">
                <h4>await()</h4>
                <div class="method-signature">int await() throws InterruptedException, BrokenBarrierException</div>
                <p>Waits until all parties have invoked await on this barrier. Returns the arrival index of the current thread.</p>
            </div>

            <div class="method-card">
                <h4>reset()</h4>
                <div class="method-signature">void reset()</div>
                <p>Resets the barrier to its initial state. Useful if the barrier breaks due to an exception.</p>
            </div>

            <div class="method-card">
                <h4>getNumberWaiting()</h4>
                <div class="method-signature">int getNumberWaiting()</div>
                <p>Returns the number of parties currently waiting at the barrier.</p>
            </div>
        </div>

        <div class="highlight-box">
            <strong>üí° Use Case:</strong> CyclicBarrier is perfect for scenarios where threads need to wait for each other
            at multiple synchronization points (e.g., parallel algorithms with multiple phases, iterative simulations).
        </div>

        <div class="highlight-box">
            <strong>üîÑ Key Advantage:</strong> Unlike CountDownLatch, CyclicBarrier is reusable! After all threads
            pass the barrier, it automatically resets for the next round.
        </div>
    </div>

    <!-- TAB 4: Comparison -->
    <div class="tab-content" id="tab3">
        <h2 style="color: #667eea; margin-bottom: 20px;">Comparison: Semaphore vs CountDownLatch vs CyclicBarrier</h2>

        <div class="demo-section">
            <h3>Quick Overview</h3>
            <table class="comparison-table">
                <tr>
                    <th>Feature</th>
                    <th>Semaphore</th>
                    <th>CountDownLatch</th>
                    <th>CyclicBarrier</th>
                </tr>
                <tr>
                    <td><strong>Purpose</strong></td>
                    <td>Limit concurrent access</td>
                    <td>Wait for multiple tasks to complete</td>
                    <td>Synchronize threads at common point</td>
                </tr>
                <tr>
                    <td><strong>Permits/Count</strong></td>
                    <td>Multiple permits</td>
                    <td>Single countdown</td>
                    <td>Fixed number of parties</td>
                </tr>
                <tr>
                    <td><strong>Reusable?</strong></td>
                    <td>‚úÖ Yes (permits recycled)</td>
                    <td>‚ùå No (one-time use)</td>
                    <td>‚úÖ Yes (automatically resets)</td>
                </tr>
                <tr>
                    <td><strong>Who Waits?</strong></td>
                    <td>Threads needing permits</td>
                    <td>One or more threads</td>
                    <td>All participating threads</td>
                </tr>
                <tr>
                    <td><strong>Release Mechanism</strong></td>
                    <td>release() by thread</td>
                    <td>countDown() by threads</td>
                    <td>await() by all threads</td>
                </tr>
                <tr>
                    <td><strong>Typical Use Case</strong></td>
                    <td>Resource pooling, rate limiting</td>
                    <td>Service startup, batch processing</td>
                    <td>Parallel algorithms, simulations</td>
                </tr>
                <tr>
                    <td><strong>Example</strong></td>
                    <td>Parking lot with limited spaces</td>
                    <td>Waiting for all runners to finish</td>
                    <td>Multiplayer game start</td>
                </tr>
            </table>
        </div>

        <div class="demo-section">
            <h3>When to Use Each?</h3>

            <div class="concept-box">
                <h3>üöó Use Semaphore When:</h3>
                <ul>
                    <li>You need to limit the number of threads accessing a resource simultaneously</li>
                    <li>You have a pool of resources (database connections, thread pool)</li>
                    <li>You want to implement rate limiting</li>
                    <li>Threads acquire and release permits independently</li>
                </ul>
            </div>

            <div class="concept-box">
                <h3>üèÉ Use CountDownLatch When:</h3>
                <ul>
                    <li>One or more threads need to wait for multiple other threads to complete</li>
                    <li>You're waiting for a set of services to start before proceeding</li>
                    <li>You need a one-time synchronization event</li>
                    <li>Master thread waits for worker threads</li>
                </ul>
            </div>

            <div class="concept-box">
                <h3>üéÆ Use CyclicBarrier When:</h3>
                <ul>
                    <li>Multiple threads need to wait for each other at a common point</li>
                    <li>You have phases in parallel computation</li>
                    <li>You need reusable synchronization (multiple rounds/iterations)</li>
                    <li>All threads participate equally in the synchronization</li>
                </ul>
            </div>
        </div>

        <div class="demo-section">
            <h3>Key Differences Summary</h3>

            <div class="method-card">
                <h4>Semaphore: Resource Control</h4>
                <p>Think of it as a <strong>gatekeeper</strong> that controls how many threads can access a resource.
                    Permits are acquired and released, allowing different threads to take turns.</p>
                <div class="code-block" style="font-size: 0.85em;">
                    semaphore.<span class="method">acquire</span>();  <span class="comment">// Get permission</span>
                    <span class="comment">// Use resource</span>
                    semaphore.<span class="method">release</span>();  <span class="comment">// Return permission</span>
                </div>
            </div>

            <div class="method-card">
                <h4>CountDownLatch: One-Way Wait</h4>
                <p>Think of it as a <strong>countdown</strong> that releases waiting threads when it reaches zero.
                    It's a one-time synchronization - once triggered, it stays open.</p>
                <div class="code-block" style="font-size: 0.85em;">
                    latch.<span class="method">await</span>();      <span class="comment">// Main thread waits</span>
                    latch.<span class="method">countDown</span>();  <span class="comment">// Worker threads count down</span>
                    <span class="comment">// When count=0, waiting thread(s) proceed</span>
                </div>
            </div>

            <div class="method-card">
                <h4>CyclicBarrier: Mutual Wait</h4>
                <p>Think of it as a <strong>meeting point</strong> where all threads wait for each other.
                    When everyone arrives, all proceed together. It resets automatically for reuse.</p>
                <div class="code-block" style="font-size: 0.85em;">
                    barrier.<span class="method">await</span>();  <span class="comment">// All threads wait at barrier</span>
                    <span class="comment">// When last thread arrives, ALL proceed together</span>
                    <span class="comment">// Barrier resets automatically for next use</span>
                </div>
            </div>
        </div>

        <div class="highlight-box">
            <strong>üéØ Bottom Line:</strong>
            <ul style="margin-top: 10px;">
                <li><strong>Semaphore</strong> - Controls access (permits)</li>
                <li><strong>CountDownLatch</strong> - One waits for many (one-time)</li>
                <li><strong>CyclicBarrier</strong> - All wait for each other (reusable)</li>
            </ul>
        </div>
    </div>
</div>

<script>
    function switchTab(index) {
        const tabs = document.querySelectorAll('.tab');
        const contents = document.querySelectorAll('.tab-content');

        tabs.forEach(tab => tab.classList.remove('active'));
        contents.forEach(content => content.classList.remove('active'));

        tabs[index].classList.add('active');
        contents[index].classList.add('active');
    }

    // Semaphore Demo
    let semaphoreRunning = false;
    async function demonstrateSemaphore() {
        if (semaphoreRunning) return;
        semaphoreRunning = true;

        const btn = document.getElementById('semaphore-btn');
        btn.disabled = true;

        const logArea = document.getElementById('semaphore-log');
        logArea.innerHTML = '';

        const spaces = [
            document.getElementById('space1'),
            document.getElementById('space2'),
            document.getElementById('space3')
        ];

        const waitingList = document.getElementById('waiting-list');
        const waitingCount = document.getElementById('waiting-count');

        // Reset spaces
        spaces.forEach(space => {
            space.textContent = 'EMPTY';
            space.classList.remove('occupied');
        });

        let availableSpaces = [0, 1, 2];
        let waiting = [];

        function log(message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function updateWaiting() {
            waitingCount.textContent = waiting.length;
            waitingList.innerHTML = waiting.map(car =>
                `<span class="car-item">üöó Car ${car}</span>`
            ).join('');
        }

        async function parkCar(carNumber) {
            log(`üöó Car ${carNumber} arriving...`);

            if (availableSpaces.length === 0) {
                waiting.push(carNumber);
                updateWaiting();
                log(`‚è≥ Car ${carNumber} waiting... (${availableSpaces.length} spaces available)`);

                // Wait for a space
                while (availableSpaces.length === 0) {
                    await sleep(100);
                }

                waiting = waiting.filter(c => c !== carNumber);
                updateWaiting();
            }

            const spaceIndex = availableSpaces.shift();
            spaces[spaceIndex].textContent = `üöó Car ${carNumber}`;
            spaces[spaceIndex].classList.add('occupied');
            log(`‚úÖ Car ${carNumber} PARKED in space ${spaceIndex + 1} (${availableSpaces.length} left)`);

            await sleep(2000);

            spaces[spaceIndex].textContent = 'EMPTY';
            spaces[spaceIndex].classList.remove('occupied');
            availableSpaces.push(spaceIndex);
            log(`üöó Car ${carNumber} LEFT space ${spaceIndex + 1} (${availableSpaces.length} available)`);
        }

        const cars = [];
        for (let i = 1; i <= 6; i++) {
            cars.push(parkCar(i));
            await sleep(300);
        }

        await Promise.all(cars);

        log('‚úÖ Demo completed!');
        btn.disabled = false;
        semaphoreRunning = false;
    }

    // CountDownLatch Demo
    let latchRunning = false;
    async function demonstrateCountDownLatch() {
        if (latchRunning) return;
        latchRunning = true;

        const btn = document.getElementById('latch-btn');
        btn.disabled = true;

        const logArea = document.getElementById('latch-log');
        logArea.innerHTML = '';

        const counter = document.getElementById('latch-counter');
        const raceStatus = document.getElementById('race-status');

        let count = 4;
        counter.textContent = `Count: ${count}`;
        raceStatus.textContent = 'üèÅ Waiting for runners to finish...';

        const lanes = [
            document.getElementById('lane1'),
            document.getElementById('lane2'),
            document.getElementById('lane3'),
            document.getElementById('lane4')
        ];

        // Reset runners
        lanes.forEach(lane => {
            const runner = lane.querySelector('.runner');
            runner.style.left = '0';
        });

        function log(message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        log('üèÅ Race started! Waiting for all runners...');

        async function runRace(runnerNumber) {
            const lane = lanes[runnerNumber - 1];
            const runner = lane.querySelector('.runner');

            log(`üèÉ Runner ${runnerNumber} running...`);

            const duration = Math.random() * 2000 + 1000;
            const startTime = Date.now();

            while (Date.now() - startTime < duration) {
                const progress = (Date.now() - startTime) / duration;
                runner.style.left = `${progress * 85}%`;
                await sleep(50);
            }

            runner.style.left = '85%';
            count--;
            counter.textContent = `Count: ${count}`;
            log(`‚úÖ Runner ${runnerNumber} FINISHED! (Remaining: ${count})`);

            if (count === 0) {
                raceStatus.textContent = 'üéâ ALL RUNNERS FINISHED! Race complete!';
                log('üéâ ALL RUNNERS FINISHED! Race complete!');
            }
        }

        const runners = [];
        for (let i = 1; i <= 4; i++) {
            runners.push(runRace(i));
            await sleep(200);
        }

        await Promise.all(runners);

        btn.disabled = false;
        latchRunning = false;
    }

    // CyclicBarrier Demo
    let barrierRunning = false;
    async function demonstrateCyclicBarrier() {
        if (barrierRunning) return;
        barrierRunning = true;

        const btn = document.getElementById('barrier-btn');
        btn.disabled = true;

        const logArea = document.getElementById('barrier-log');
        logArea.innerHTML = '';

        const barrierStatus = document.getElementById('barrier-status');
        const roundStatus = document.getElementById('round-status');

        const playerStatuses = [
            document.getElementById('player1-status'),
            document.getElementById('player2-status'),
            document.getElementById('player3-status')
        ];

        let arrivedCount = 0;
        const totalPlayers = 3;

        function log(message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        async function waitAtBarrier(playerNumber) {
            arrivedCount++;
            log(`üë§ Player ${playerNumber} arrived at barrier (${arrivedCount}/${totalPlayers})`);
            barrierStatus.textContent = `‚è≥ Waiting... ${arrivedCount}/${totalPlayers} players ready`;

            while (arrivedCount < totalPlayers) {
                await sleep(100);
            }
        }

        async function playGame(playerNumber) {
            const status = playerStatuses[playerNumber - 1];

            // Phase 1: Loading
            log(`üë§ Player ${playerNumber} loading game...`);
            status.textContent = 'Loading...';
            status.className = 'player-status status-loading';
            await sleep(Math.random() * 1500 + 500);

            status.textContent = 'Ready!';
            status.className = 'player-status status-ready';

            await waitAtBarrier(playerNumber);

            if (playerNumber === 1) {
                barrierStatus.textContent = '‚úÖ ALL PLAYERS READY! Game starting...';
                barrierStatus.classList.add('open');
                roundStatus.textContent = 'üéÆ Round 1 in progress...';
                log('üéÆ ALL PLAYERS READY! Game starting...');
                await sleep(500);
                arrivedCount = 0; // Reset for next barrier
            }

            // Phase 2: Round 1
            log(`üéÆ Player ${playerNumber} playing Round 1`);
            status.textContent = 'Playing Round 1';
            status.className = 'player-status status-playing';
            await sleep(1500);

            status.textContent = 'Round 1 Done';
            status.className = 'player-status status-ready';
            log(`‚úÖ Player ${playerNumber} finished Round 1`);

            await waitAtBarrier(playerNumber);

            if (playerNumber === 1) {
                barrierStatus.textContent = '‚úÖ Round 1 Complete! Starting Round 2...';
                roundStatus.textContent = 'üéÆ Round 2 in progress...';
                log('üéÆ Starting Round 2...');
                await sleep(500);
            }

            // Phase 3: Round 2
            log(`üéÆ Player ${playerNumber} playing Round 2`);
            status.textContent = 'Playing Round 2';
            status.className = 'player-status status-playing';
            await sleep(1000);

            status.textContent = 'Completed!';
            status.className = 'player-status status-ready';
            log(`üèÜ Player ${playerNumber} completed!`);

            if (playerNumber === 3) {
                roundStatus.textContent = 'üèÜ All rounds completed!';
            }
        }

        barrierStatus.textContent = 'üö´ BARRIER CLOSED - Waiting for all players...';
        barrierStatus.classList.remove('open');
        roundStatus.textContent = 'Waiting for players to load...';
        arrivedCount = 0;

        const players = [];
        for (let i = 1; i <= 3; i++) {
            players.push(playGame(i));
            await sleep(300);
        }

        await Promise.all(players);

        log('‚úÖ Demo completed!');
        btn.disabled = false;
        barrierRunning = false;
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
</script>
</body>
</html>
